<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script>
        // Forward console logs to React Native FIRST (before any other scripts)
        (function() {
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            
            console.log = function(...args) {
                window.ReactNativeWebView?.postMessage(JSON.stringify({
                    type: 'console',
                    level: 'log',
                    message: args.join(' ')
                }));
                originalLog.apply(console, args);
            };
            
            console.error = function(...args) {
                window.ReactNativeWebView?.postMessage(JSON.stringify({
                    type: 'console',
                    level: 'error',
                    message: args.join(' ')
                }));
                originalError.apply(console, args);
            };
            
            console.warn = function(...args) {
                window.ReactNativeWebView?.postMessage(JSON.stringify({
                    type: 'console',
                    level: 'warn',
                    message: args.join(' ')
                }));
                originalWarn.apply(console, args);
            };
        })();
    </script>
    <script>
        // Intercept fetch to track MediaPipe model downloads
        (function() {
            const downloadProgress = new Map();
            let totalFiles = 0;
            let loadedFiles = 0;
            
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                
                // Only track MediaPipe files
                if (typeof url === 'string' && url.includes('mediapipe/pose')) {
                    const fileName = url.split('/').pop();
                    totalFiles++;
                    
                    console.log(`ðŸ“¥ [MediaPipe] Downloading: ${fileName}`);
                    window.ReactNativeWebView?.postMessage(JSON.stringify({
                        type: 'download_progress',
                        fileName: fileName,
                        status: 'started',
                        loaded: loadedFiles,
                        total: totalFiles
                    }));
                    
                    return originalFetch.apply(this, args).then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load ${fileName}: ${response.status}`);
                        }
                        
                        const contentLength = response.headers.get('content-length');
                        const total = contentLength ? parseInt(contentLength, 10) : 0;
                        
                        if (!contentLength || total === 0) {
                            // No content-length header, just track completion
                            loadedFiles++;
                            console.log(`âœ… [MediaPipe] Downloaded: ${fileName} (${loadedFiles}/${totalFiles})`);
                            window.ReactNativeWebView?.postMessage(JSON.stringify({
                                type: 'download_progress',
                                fileName: fileName,
                                status: 'complete',
                                loaded: loadedFiles,
                                total: totalFiles
                            }));
                            return response;
                        }
                        
                        // Stream the response to track bytes
                        const reader = response.body.getReader();
                        let receivedLength = 0;
                        const chunks = [];
                        
                        const stream = new ReadableStream({
                            async start(controller) {
                                while (true) {
                                    const {done, value} = await reader.read();
                                    
                                    if (done) break;
                                    
                                    chunks.push(value);
                                    receivedLength += value.length;
                                    
                                    const percent = (receivedLength / total) * 100;
                                    
                                    // Throttle progress updates (every 10%)
                                    if (percent % 10 < 2 || percent > 95) {
                                        console.log(`ðŸ“Š [MediaPipe] ${fileName}: ${(receivedLength / 1024 / 1024).toFixed(2)}MB / ${(total / 1024 / 1024).toFixed(2)}MB (${percent.toFixed(1)}%)`);
                                        
                                        window.ReactNativeWebView?.postMessage(JSON.stringify({
                                            type: 'download_progress',
                                            fileName: fileName,
                                            status: 'downloading',
                                            receivedBytes: receivedLength,
                                            totalBytes: total,
                                            percent: percent,
                                            loaded: loadedFiles,
                                            total: totalFiles
                                        }));
                                    }
                                    
                                    controller.enqueue(value);
                                }
                                
                                loadedFiles++;
                                console.log(`âœ… [MediaPipe] Downloaded: ${fileName} - ${(receivedLength / 1024 / 1024).toFixed(2)}MB (${loadedFiles}/${totalFiles} files)`);
                                
                                window.ReactNativeWebView?.postMessage(JSON.stringify({
                                    type: 'download_progress',
                                    fileName: fileName,
                                    status: 'complete',
                                    receivedBytes: receivedLength,
                                    totalBytes: total,
                                    loaded: loadedFiles,
                                    total: totalFiles
                                }));
                                
                                controller.close();
                            }
                        });
                        
                        return new Response(stream, {
                            headers: response.headers
                        });
                    });
                }
                
                return originalFetch.apply(this, args);
            };
            
            console.log('ðŸ“¡ [MediaPipe] Fetch interceptor installed for download tracking');
        })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        .container { 
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .video-player {
            position: absolute;
            /* keep hidden but allow playback */
            width: 1px;
            height: 1px;
            opacity: 0.01;
        }
    </style>
</head>

<body>
    <div class="container">
        <video class="video-player" width="1280px" height="720px"></video>
        <canvas id="output_canvas" width="1280px" height="720px"></canvas>
    </div>
    <script>
        console.log('ðŸŽ¬ [MediaPipe] Script started - Creating Pose instance...');
        
        // MediaPipe Pose instance
        const pose = new Pose({
            locateFile: (file) => {
                const url = `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                console.log(`ðŸ“¦ [MediaPipe] locateFile requested: ${file} -> ${url}`);
                return url;
            }
        });

        console.log('âœ… [MediaPipe] Pose instance created successfully');

        // Configure pose detection
        const poseOptions = {
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.4
        };
        
        console.log('âš™ï¸ [MediaPipe] Setting options:', poseOptions);
        pose.setOptions(poseOptions);
        console.log('âœ… [MediaPipe] Options set successfully');
        
        // Model complexity lookup
        const MODEL_NAMES = { 0: 'Lite', 1: 'Full', 2: 'Heavy' };
        
        // Log configuration
        console.log(`ðŸ“Š [MediaPipe] Configuration: Model complexity ${poseOptions.modelComplexity} (${MODEL_NAMES[poseOptions.modelComplexity] || 'Unknown'})`);
        console.log(`ðŸ“Š [MediaPipe] Detection confidence: ${poseOptions.minDetectionConfidence}`);
        console.log(`ðŸ“Š [MediaPipe] Tracking confidence: ${poseOptions.minTrackingConfidence}`);

    // Setup video and canvas elements
        console.log('ðŸŽ¨ [MediaPipe] Setting up video and canvas elements...');
        const videoElement = document.querySelector('.video-player');
        const canvasElement = document.querySelector('#output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        console.log('âœ… [MediaPipe] Video and canvas elements ready');
        const results = {
            frames: [],
            metadata: {
                frame_count: 0,
                width: 0,
                height: 0,
                fps: 0
            }
        };
        let processing = false;
        let totalFrames = 0;
        let targetFps = 30;

        // Handle messages from React Native (support both window and document listeners)
        const messageHandler = async function(event) {
            try {
                const raw = event?.data ?? event;
                const message = typeof raw === 'string' ? JSON.parse(raw) : JSON.parse(String(raw));

                if (message.type === 'process_video') {
                    console.log('ðŸ“¨ [MediaPipe] Received process_video message');
                    console.log(`ðŸ“Š [MediaPipe] Video data size: ${message.video ? message.video.length : 0} bytes`);
                    
                    // Acknowledge receipt
                    window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'status', message: 'Received video. Preparing...' }));
                    try {
                        console.log('ðŸŽ¬ [MediaPipe] Preparing video element...');
                        // Prepare video element for autoplay policies
                        videoElement.muted = true;
                        videoElement.playsInline = true;
                        videoElement.src = message.video;

                        console.log('â³ [MediaPipe] Waiting for video metadata...');
                        // Wait for metadata to load
                        await new Promise((resolve, reject) => {
                            const onMeta = () => { cleanup(); resolve(); };
                            const onErr = (e) => { cleanup(); reject(e); };
                            const cleanup = () => {
                                videoElement.removeEventListener('loadedmetadata', onMeta);
                                videoElement.removeEventListener('error', onErr);
                            };
                            videoElement.addEventListener('loadedmetadata', onMeta, { once: true });
                            videoElement.addEventListener('error', onErr, { once: true });
                        });

                        console.log('âœ… [MediaPipe] Video metadata loaded');
                        
                        // Prepare processing settings
                        results.frames = [];
                        results.metadata.frame_count = 0;
                        results.metadata.width = videoElement.videoWidth || 0;
                        results.metadata.height = videoElement.videoHeight || 0;
                        targetFps = Number(message.options?.fps) || 30;
                        results.metadata.fps = targetFps;

                        const duration = Math.max(0, Number(videoElement.duration) || 0);
                        totalFrames = Math.max(1, Math.floor(duration * targetFps));

                        console.log(`ðŸ“Š [MediaPipe] Video info: ${results.metadata.width}x${results.metadata.height}, ${duration.toFixed(2)}s, ${totalFrames} frames at ${targetFps} fps`);

                        // Deterministic, seek-driven processing (no reliance on videoElement.ended)
                        processing = true;
                        videoElement.pause();
                        window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'status', message: `Starting poseâ€¦ ${totalFrames} frames @ ${targetFps}fps` }));

                        await processVideo(duration);
                    } catch (error) {
                        window.ReactNativeWebView?.postMessage?.(JSON.stringify({
                            type: 'error',
                            message: error?.message || String(error)
                        }));
                    }
                }
            } catch (e) {
                window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'error', message: 'Failed to parse message: ' + (e?.message || String(e)) }));
            }
        };
        window.addEventListener('message', messageHandler);
        document.addEventListener('message', messageHandler);

        // Process video frames
        async function processVideo(duration) {
            console.log(`ðŸŽ¥ [MediaPipe] Starting video processing - Duration: ${duration}s, Total frames: ${totalFrames}`);
            
            // Install results handler once per processing session
            pose.onResults((poseResults) => {
                if (!processing) return;
                if (poseResults.poseLandmarks) {
                    // Log first frame detection
                    if (results.metadata.frame_count === 0) {
                        console.log('âœ… [MediaPipe] First frame processed successfully - pose detected!');
                        console.log(`ðŸ“Š [MediaPipe] Landmarks detected: ${poseResults.poseLandmarks.length} points`);
                    }
                    // Store landmarks for this frame
                    results.frames.push({
                        frame_index: results.metadata.frame_count,
                        landmarks: poseResults.poseLandmarks.map(landmark => ({
                            x: landmark.x,
                            y: landmark.y,
                            z: landmark.z,
                            visibility: landmark.visibility
                        }))
                    });

                    // Update progress
                    results.metadata.frame_count++;
                    const progress = totalFrames > 0 ? (results.metadata.frame_count / totalFrames) * 100 : 0;
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'progress',
                        frameIndex: results.metadata.frame_count,
                        percent: progress
                    }));

                    // Optional: Draw landmarks for debugging
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(poseResults.image, 0, 0, canvasElement.width, canvasElement.height);
                    if (poseResults.poseLandmarks) {
                        drawConnectors(canvasCtx, poseResults.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                        drawLandmarks(canvasCtx, poseResults.poseLandmarks, { color: '#FF0000', lineWidth: 1 });
                    }
                    canvasCtx.restore();
                }
            });

            // Seek-based deterministic sampling
            for (let i = 0; i < totalFrames && processing; i++) {
                const t = Math.min(duration, i / targetFps);
                await new Promise((resolve, reject) => {
                    const onSeeked = () => { cleanup(); resolve(); };
                    const onErr = (e) => { cleanup(); reject(e); };
                    const cleanup = () => {
                        videoElement.removeEventListener('seeked', onSeeked);
                        videoElement.removeEventListener('error', onErr);
                    };
                    videoElement.addEventListener('seeked', onSeeked, { once: true });
                    videoElement.addEventListener('error', onErr, { once: true });
                    videoElement.currentTime = t;
                });

                await pose.send({ image: videoElement });
            }

            processing = false;
            console.log(`âœ… [MediaPipe] Video processing complete - ${results.metadata.frame_count} frames extracted`);
            
            // Send final results once loop completes
            window.ReactNativeWebView.postMessage(JSON.stringify({
                type: 'complete',
                results
            }));

            // Reset video position
            videoElement.currentTime = 0;
        }

        // Send ready status
        console.log('ðŸŽ‰ [MediaPipe] Initialization complete - Ready to process videos!');
        window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'status',
            message: `MediaPipe Pose initialized (Model: ${MODEL_NAMES[poseOptions.modelComplexity] || 'Unknown'} [${poseOptions.modelComplexity}])`
        }));
    </script>
</body>
</html>