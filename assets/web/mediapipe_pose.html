<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script>
        // IMMEDIATE test log - before any other code
        if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
                type: 'console',
                level: 'log',
                message: 'üî• [HTML] IMMEDIATE LOG - ReactNativeWebView exists!'
            }));
        }
        
        // Forward console logs to React Native FIRST (before any other scripts)
        (function() {
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            
            console.log = function(...args) {
                try {
                    window.ReactNativeWebView?.postMessage(JSON.stringify({
                        type: 'console',
                        level: 'log',
                        message: args.join(' ')
                    }));
                } catch (e) {
                    // Silently fail if postMessage doesn't work
                }
                originalLog.apply(console, args);
            };
            
            console.error = function(...args) {
                try {
                    window.ReactNativeWebView?.postMessage(JSON.stringify({
                        type: 'console',
                        level: 'error',
                        message: args.join(' ')
                    }));
                } catch (e) {
                    // Silently fail
                }
                originalError.apply(console, args);
            };
            
            console.warn = function(...args) {
                try {
                    window.ReactNativeWebView?.postMessage(JSON.stringify({
                        type: 'console',
                        level: 'warn',
                        message: args.join(' ')
                    }));
                } catch (e) {
                    // Silently fail
                }
                originalWarn.apply(console, args);
            };
            
            // Test the console forwarding immediately
            console.log('üî• [HTML] Console forwarding installed and tested!');
        })();
    </script>
    <script>
        // Intercept fetch to track MediaPipe model downloads
        (function() {
            const downloadProgress = new Map();
            let totalFiles = 0;
            let loadedFiles = 0;
            
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                
                // Log ALL fetch calls to see what's being requested
                console.log(`üîç [Fetch] Called with URL:`, typeof url === 'string' ? url.substring(0, 100) : url);
                
                // Intercept requests for inlined files
                if (url === 'INLINED' || 
                    (typeof url === 'string' && (
                        url.includes('pose_solution_packed_assets_loader.js') || 
                        url.includes('pose_solution_simd_wasm_bin.js')
                    ))) {
                    const fileName = url === 'INLINED' ? 'inlined script' : url.split('/').pop();
                    console.log(`‚ö†Ô∏è [MediaPipe] Blocked redundant request for ${fileName} (already inlined as script tag)`);
                    // Return empty success response since these are already loaded
                    return Promise.resolve(new Response('', {
                        status: 200,
                        statusText: 'OK',
                        headers: { 'Content-Type': 'application/javascript' }
                    }));
                }
                
                // Track all MediaPipe-related files (data URLs, relative paths, and file:// URIs)
                if (typeof url === 'string' && (
                    url.startsWith('data:') ||
                    url.includes('mediapipe/pose') || 
                    url.startsWith('file://') ||
                    url.includes('.tflite') ||
                    url.includes('.wasm') ||
                    url.includes('.data') ||
                    url.includes('.binarypb')
                )) {
                    // Extract filename from URL or data URL
                    let fileName;
                    if (url.startsWith('data:')) {
                        // For data URLs, we can't extract filename from URL
                        // Check window.MEDIAPIPE_FILE_URIS to find which file this is
                        fileName = 'data-url-file';
                        if (window.MEDIAPIPE_FILE_URIS) {
                            for (const [name, uri] of Object.entries(window.MEDIAPIPE_FILE_URIS)) {
                                if (uri === url) {
                                    fileName = name;
                                    break;
                                }
                            }
                        }
                    } else {
                        fileName = url.split('/').pop();
                    }
                    
                    totalFiles++;
                    
                    console.log(`üì• [MediaPipe] Downloading: ${fileName}`);
                    window.ReactNativeWebView?.postMessage(JSON.stringify({
                        type: 'download_progress',
                        fileName: fileName,
                        status: 'started',
                        loaded: loadedFiles,
                        total: totalFiles
                    }));
                    
                    return originalFetch.apply(this, args)
                        .then(response => {
                            console.log(`üì¶ [MediaPipe] Fetch response for ${fileName}: status=${response.status}, ok=${response.ok}`);
                            
                            if (!response.ok) {
                                console.error(`‚ùå [MediaPipe] Failed to load ${fileName}: HTTP ${response.status} ${response.statusText}`);
                                throw new Error(`Failed to load ${fileName}: ${response.status}`);
                            }
                            
                            const contentLength = response.headers.get('content-length');
                            const total = contentLength ? parseInt(contentLength, 10) : 0;
                            console.log(`üì¶ [MediaPipe] ${fileName} content-length: ${total || 'unknown'} bytes`);
                            
                            if (!contentLength || total === 0) {
                                // No content-length header, just track completion
                                loadedFiles++;
                                console.log(`‚úÖ [MediaPipe] Downloaded: ${fileName} (${loadedFiles}/${totalFiles})`);
                                window.ReactNativeWebView?.postMessage(JSON.stringify({
                                    type: 'download_progress',
                                    fileName: fileName,
                                    status: 'complete',
                                    loaded: loadedFiles,
                                    total: totalFiles
                                }));
                                return response;
                            }
                        
                        // Stream the response to track bytes
                        const reader = response.body.getReader();
                        let receivedLength = 0;
                        const chunks = [];
                        
                        const stream = new ReadableStream({
                            async start(controller) {
                                while (true) {
                                    const {done, value} = await reader.read();
                                    
                                    if (done) break;
                                    
                                    chunks.push(value);
                                    receivedLength += value.length;
                                    
                                    const percent = (receivedLength / total) * 100;
                                    
                                    // Throttle progress updates (every 10%)
                                    if (percent % 10 < 2 || percent > 95) {
                                        console.log(`üìä [MediaPipe] ${fileName}: ${(receivedLength / 1024 / 1024).toFixed(2)}MB / ${(total / 1024 / 1024).toFixed(2)}MB (${percent.toFixed(1)}%)`);
                                        
                                        window.ReactNativeWebView?.postMessage(JSON.stringify({
                                            type: 'download_progress',
                                            fileName: fileName,
                                            status: 'downloading',
                                            receivedBytes: receivedLength,
                                            totalBytes: total,
                                            percent: percent,
                                            loaded: loadedFiles,
                                            total: totalFiles
                                        }));
                                    }
                                    
                                    controller.enqueue(value);
                                }
                                
                                loadedFiles++;
                                console.log(`‚úÖ [MediaPipe] Downloaded: ${fileName} - ${(receivedLength / 1024 / 1024).toFixed(2)}MB (${loadedFiles}/${totalFiles} files)`);
                                
                                window.ReactNativeWebView?.postMessage(JSON.stringify({
                                    type: 'download_progress',
                                    fileName: fileName,
                                    status: 'complete',
                                    receivedBytes: receivedLength,
                                    totalBytes: total,
                                    loaded: loadedFiles,
                                    total: totalFiles
                                }));
                                
                                controller.close();
                            }
                        });
                        
                        return new Response(stream, {
                            headers: response.headers
                        });
                    })
                    .catch(error => {
                        console.error(`‚ùå [MediaPipe] Fetch error for ${fileName}:`, error.name, error.message);
                        console.error(`‚ùå [MediaPipe] Fetch URL was:`, url);
                        window.ReactNativeWebView?.postMessage(JSON.stringify({
                            type: 'error',
                            message: `Failed to fetch ${fileName}: ${error.message}`
                        }));
                        throw error;
                    });
                }
                
                return originalFetch.apply(this, args);
            };
            
            console.log('üì° [MediaPipe] Fetch interceptor installed for download tracking');
        })();
    </script>
    <!-- MediaPipe libraries - PLACEHOLDER - Will be replaced by React Native -->
    <!-- MEDIAPIPE_SCRIPTS_PLACEHOLDER -->
    <style>
        .container { 
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .video-player {
            position: absolute;
            /* keep hidden but allow playback */
            width: 1px;
            height: 1px;
            opacity: 0.01;
        }
    </style>
</head>

<body>
    <div class="container">
        <video class="video-player" width="1280px" height="720px"></video>
        <canvas id="output_canvas" width="1280px" height="720px"></canvas>
    </div>
    <script>
        // Wrap entire script in try-catch to catch initialization errors
        try {
            console.log('üé¨ [MediaPipe] Script started - Checking if Pose is defined...');
            
            if (typeof Pose === 'undefined') {
                throw new Error('Pose class is not defined! MediaPipe libraries may not have loaded correctly.');
            }
            
            console.log('‚úÖ [MediaPipe] Pose class is available');
            console.log('üé¨ [MediaPipe] Creating Pose instance...');
            
            // MediaPipe Pose instance
            const pose = new Pose({
                locateFile: (file) => {
                    console.log(`üîé [MediaPipe] locateFile called for: "${file}"`);
                    console.log(`üîé [MediaPipe] Available keys in MEDIAPIPE_FILE_URIS:`, window.MEDIAPIPE_FILE_URIS ? Object.keys(window.MEDIAPIPE_FILE_URIS) : 'undefined');
                    
                    // Use injected file URIs if available (for offline binary files)
                    if (window.MEDIAPIPE_FILE_URIS && window.MEDIAPIPE_FILE_URIS[file]) {
                        const uri = window.MEDIAPIPE_FILE_URIS[file];
                        console.log(`üì¶ [MediaPipe] locateFile requested: ${file} -> ${uri.substring(0, 80)}... (from injected URI)`);
                        return uri;
                    }
                    
                    // Fallback to relative path (shouldn't be needed if all files are injected)
                    const url = `../mediapipe/${file}`;
                    console.log(`‚ö†Ô∏è [MediaPipe] locateFile requested: ${file} -> ${url} (FALLBACK - FILE NOT IN URIS!)`);
                    return url;
                }
            });

            console.log('‚úÖ [MediaPipe] Pose instance created successfully');

        // Configure pose detection
        const poseOptions = {
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.4
        };
        
        console.log('‚öôÔ∏è [MediaPipe] Setting options:', poseOptions);
        pose.setOptions(poseOptions);
        console.log('‚úÖ [MediaPipe] Options set successfully');
        console.log('‚è≥ [MediaPipe] Initializing pose detection (loading models)...');
        
        // Model complexity lookup
        const MODEL_NAMES = { 0: 'Lite', 1: 'Full', 2: 'Heavy' };
        
        // Log configuration
        console.log(`üìä [MediaPipe] Configuration: Model complexity ${poseOptions.modelComplexity} (${MODEL_NAMES[poseOptions.modelComplexity] || 'Unknown'})`);
        console.log(`üìä [MediaPipe] Detection confidence: ${poseOptions.minDetectionConfidence}`);
        console.log(`üìä [MediaPipe] Tracking confidence: ${poseOptions.minTrackingConfidence}`);

    // Setup video and canvas elements
        console.log('üé® [MediaPipe] Setting up video and canvas elements...');
        const videoElement = document.querySelector('.video-player');
        const canvasElement = document.querySelector('#output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        console.log('‚úÖ [MediaPipe] Video and canvas elements ready');
        const results = {
            frames: [],
            metadata: {
                frame_count: 0,
                width: 0,
                height: 0,
                fps: 0
            }
        };
        let processing = false;
        let totalFrames = 0;
        let targetFps = 30;

        // Handle messages from React Native (support both window and document listeners)
        const messageHandler = async function(event) {
            try {
                const raw = event?.data ?? event;
                const message = typeof raw === 'string' ? JSON.parse(raw) : JSON.parse(String(raw));

                if (message.type === 'process_video') {
                    console.log('üì® [MediaPipe] Received process_video message');
                    console.log(`üìä [MediaPipe] Video data size: ${message.video ? message.video.length : 0} bytes`);
                    
                    // Acknowledge receipt
                    window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'status', message: 'Received video. Preparing...' }));
                    try {
                        console.log('üé¨ [MediaPipe] Preparing video element...');
                        // Prepare video element for autoplay policies
                        videoElement.muted = true;
                        videoElement.playsInline = true;
                        videoElement.src = message.video;

                        console.log('‚è≥ [MediaPipe] Waiting for video metadata...');
                        // Wait for metadata to load
                        await new Promise((resolve, reject) => {
                            const onMeta = () => { cleanup(); resolve(); };
                            const onErr = (e) => { cleanup(); reject(e); };
                            const cleanup = () => {
                                videoElement.removeEventListener('loadedmetadata', onMeta);
                                videoElement.removeEventListener('error', onErr);
                            };
                            videoElement.addEventListener('loadedmetadata', onMeta, { once: true });
                            videoElement.addEventListener('error', onErr, { once: true });
                        });

                        console.log('‚úÖ [MediaPipe] Video metadata loaded');
                        
                        // Prepare processing settings
                        results.frames = [];
                        results.metadata.frame_count = 0;
                        results.metadata.width = videoElement.videoWidth || 0;
                        results.metadata.height = videoElement.videoHeight || 0;
                        targetFps = Number(message.options?.fps) || 30;
                        results.metadata.fps = targetFps;

                        const duration = Math.max(0, Number(videoElement.duration) || 0);
                        totalFrames = Math.max(1, Math.floor(duration * targetFps));

                        console.log(`üìä [MediaPipe] Video info: ${results.metadata.width}x${results.metadata.height}, ${duration.toFixed(2)}s, ${totalFrames} frames at ${targetFps} fps`);

                        // Send metadata with total frames to React Native before processing starts
                        window.ReactNativeWebView?.postMessage?.(JSON.stringify({ 
                            type: 'metadata', 
                            totalFrames: totalFrames,
                            width: results.metadata.width,
                            height: results.metadata.height,
                            duration: duration,
                            fps: targetFps
                        }));

                        // Deterministic, seek-driven processing (no reliance on videoElement.ended)
                        processing = true;
                        videoElement.pause();
                        window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'status', message: `Starting pose‚Ä¶ ${totalFrames} frames @ ${targetFps}fps` }));

                        await processVideo(duration);
                    } catch (error) {
                        window.ReactNativeWebView?.postMessage?.(JSON.stringify({
                            type: 'error',
                            message: error?.message || String(error)
                        }));
                    }
                }
            } catch (e) {
                window.ReactNativeWebView?.postMessage?.(JSON.stringify({ type: 'error', message: 'Failed to parse message: ' + (e?.message || String(e)) }));
            }
        };
        window.addEventListener('message', messageHandler);
        document.addEventListener('message', messageHandler);

        // Process video frames
        async function processVideo(duration) {
            console.log(`üé• [MediaPipe] Starting video processing - Duration: ${duration}s, Total frames: ${totalFrames}`);
            
            // Install results handler once per processing session
            pose.onResults((poseResults) => {
                if (!processing) return;
                if (poseResults.poseLandmarks) {
                    // Log first frame detection
                    if (results.metadata.frame_count === 0) {
                        console.log('‚úÖ [MediaPipe] First frame processed successfully - pose detected!');
                        console.log(`üìä [MediaPipe] Landmarks detected: ${poseResults.poseLandmarks.length} points`);
                    }
                    // Store landmarks for this frame
                    results.frames.push({
                        frame_index: results.metadata.frame_count,
                        landmarks: poseResults.poseLandmarks.map(landmark => ({
                            x: landmark.x,
                            y: landmark.y,
                            z: landmark.z,
                            visibility: landmark.visibility
                        }))
                    });

                    // Update progress
                    results.metadata.frame_count++;
                    const progress = totalFrames > 0 ? (results.metadata.frame_count / totalFrames) * 100 : 0;
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'progress',
                        frameIndex: results.metadata.frame_count,
                        percent: progress
                    }));

                    // Optional: Draw landmarks for debugging
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(poseResults.image, 0, 0, canvasElement.width, canvasElement.height);
                    if (poseResults.poseLandmarks) {
                        drawConnectors(canvasCtx, poseResults.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                        drawLandmarks(canvasCtx, poseResults.poseLandmarks, { color: '#FF0000', lineWidth: 1 });
                    }
                    canvasCtx.restore();
                }
            });

            // Seek-based deterministic sampling
            for (let i = 0; i < totalFrames && processing; i++) {
                const t = Math.min(duration, i / targetFps);
                await new Promise((resolve, reject) => {
                    const onSeeked = () => { cleanup(); resolve(); };
                    const onErr = (e) => { cleanup(); reject(e); };
                    const cleanup = () => {
                        videoElement.removeEventListener('seeked', onSeeked);
                        videoElement.removeEventListener('error', onErr);
                    };
                    videoElement.addEventListener('seeked', onSeeked, { once: true });
                    videoElement.addEventListener('error', onErr, { once: true });
                    videoElement.currentTime = t;
                });

                await pose.send({ image: videoElement });
            }

            processing = false;
            console.log(`‚úÖ [MediaPipe] Video processing complete - ${results.metadata.frame_count} frames extracted`);
            
            // Send final results once loop completes
            window.ReactNativeWebView.postMessage(JSON.stringify({
                type: 'complete',
                results
            }));

            // Reset video position
            videoElement.currentTime = 0;
        }

        // Send ready status
        console.log('üéâ [MediaPipe] Initialization complete - Ready to process videos!');
        window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'status',
            message: `MediaPipe Pose initialized (Model: ${MODEL_NAMES[poseOptions.modelComplexity] || 'Unknown'} [${poseOptions.modelComplexity}])`
        }));
        
    } catch (error) {
        console.error('üí• [MediaPipe] FATAL ERROR during initialization:', error);
        console.error('Error name:', error.name);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        
        window.ReactNativeWebView?.postMessage?.(JSON.stringify({
            type: 'error',
            message: `MediaPipe initialization failed: ${error.message}`
        }));
    }
    </script>
</body>
</html>